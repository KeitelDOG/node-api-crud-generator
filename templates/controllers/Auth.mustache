const {{Entity}} = require('../../models/{{Entity}}.js');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');

//Function to encrypt {{secret}}
exports.hashPass = (pass, cb) => {
  bcrypt.hash(pass, 10, function(err, hash) {
    cb(hash);
  });
};

//Function to decrypt {{secret}}
exports.decrypt = ({{secret}}, hashPass, cb) => {
  bcrypt.compare({{secret}}, hashPass, function(err, res) {
    cb(err, res);
  });
};

// Signup method for {{entity}}
exports.signup = (req, res) => {
  let data = req.body;

  exports.hashPass(data.{{secret}}, ({{secret}})=>{
    data.{{secret}} = {{secret}};
    {{Entity}}.insert(data, (error, {{entity}})  => {
      if (error) {
        res.status(403).send({
          message: "Can't signup the {{entity}}",
          error
        });
      } else {
        res.status(200).send({{entity}});
      }
    });
  });
};

// Create {{entity}} signin process
exports.signin = (req, res) => {
  let data = req.body;

  {{Entity}}.findBy{{Identification}}(data.{{identification}}, (error, {{entity}}) => {
    if (error) {
      res.status(400).send({ message: '{{Identification}} does not exists' });
    } else {
      exports.decrypt(data.{{secret}}, {{entity}}.{{secret}}, (error, response) => {
        if(error) {
          res.status(400).send({ message: 'Wrong {{entity}} credentials' });
        }else {
          delete {{entity}}.{{secret}};
          let token = jwt.sign({{entity}}, process.env.JWT_SECRET, { expiresIn: '720h' });
          res.status(200).send({ token, {{entity}} });
        }
      });
    }
  });
};
